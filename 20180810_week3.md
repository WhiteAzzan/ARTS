# ARTS
algorithm, review, tips, share

## Algorithm

1.存在重复
给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

示例 1:

输入: [1,2,3,1]
输出: true
示例 2:

输入: [1,2,3,4]
输出: false
示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true

思路：python当中的set集合本身就是没有重复元素的，我们可以利用这个特性去判断真假
```
class Solution:
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if len(set(nums)) == len(nums):
            return False
        else:
            return True
```
2.只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

思路：python的特点就是代码少，运算的比较慢，我们可以先把整个数组排序，如果只有一个数，那就是他了，如果不止一个数，看前两个是不是一样，一样的话
就把他们都删除，不一样就取第一个数。
```
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        for i in range(len(nums)):
            if len(nums) == 1:
                return nums[0]
            if nums[0] == nums[1]:
                del nums[0]
                del nums[0]
            else:
                return nums[0]
```

## Review
[Machine Learning _SVM](https://en.wikipedia.org/wiki/Support_vector_machine)

svm有三宝：间隔对偶核函数
SVM支持向量机是有监督学习里的分类算法，通过一个或者多个超平面去分开多维空间中的事物，超平面与两种类别的分类数据之间的距离有比较明确的公式规定
![超平面分开了两类数据](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/Svm_max_sep_hyperplane_with_margin.png/220px-Svm_max_sep_hyperplane_with_margin.png)
![超平面上面](https://wikimedia.org/api/rest_v1/media/math/render/svg/a677ed33ca0c840aa9295405fc095c8aefa73e48)
![超平面下面](https://wikimedia.org/api/rest_v1/media/math/render/svg/6c3dbeeb7d5af27a2551ec07ce172ddbce62fc58)
这被称为是硬间隔
那么在+1和-1这两类数据之外的就应该是属于那类了。

公式在求导的过程中使用了duality的性质，对偶问题往往是可以解决比较复杂的问题的。

核函数是专门用来解决线性不可分的情况的，把低维的事物映射到高维的空间的话可以很好地解决这个问题。而![](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ae7b54ee1b37e28f5e48330d094f7d9a8c14873)
我们并不需要等号右边地高维的是多少维，因为我们可以通过特殊的核函数去代表，去计算就好。

svm可以解决文本分类还有图像分割，图像识别的种种问题。期待解决项目上的难题~

## Tips

数据结构中的非线性结构，为什么要学？因为数据结构是研究数据的存储和数据的操作的一门学问，我们要把数据存储在电脑的硬盘上，而硬盘都是线性存储的，我们生活中会遇到很多非线性的问题，所以需要把非线性转为线性的问题。就像SVM一样，我们无法用线性的方法处理非线性的问题的时候，就把维度升高，用核函数来解决这个问题。

那么非线性的二叉树要怎么去表示呢？
具体方法：设法保证任意一个节点的 左指针域指向他的一个孩子节点，右指针域指向它的下一个兄弟。

操作：
1.先序遍历：先访问根节点
           再先序访问左子树
           再先序访问右子树
           
2.中序遍历：中序遍历左子树
           再访问根节点
           再中序遍历右子树
           
3.后序遍历：
            中序遍历左子树
            中序遍历右子树
            再访问根节点
            
查找和排序关系：排序是查找的前提
                排序是重点
 重点是快排：找个枢纽值，比一下，再在两堆中分别找枢纽值，比较。最后一定可以得到排好的数
 

## Share

最近读吴军老师的《谷歌方法论》有下面的感悟：

生活一般是有规律的，但是如果你按照规律去工作和生活，可以活的还不错，但是并不能真正体验世界的美妙，我们接触新的信息，并不是要让自己的生活变得更凌乱，而是要消除不确定性，了解更多有关这个宇宙，和自己的方方面面。所以我们学习知识也是这样，道理都是相通的，就在于你怎么去把有规律的掌握好，无规律的通过学习去探索新知。

人工智能现在如此火热，学习的门槛却比较高，但是能给人类带来无尽的好处，所以，学习是反人性的过程，认识自己也是，要想处事不惊，就得有一种莫名的自信，自己去开启那个大门

为什么别人就能得出通信和语音识别，机器翻译是等价问题？我想有这么几点:

1.人是有天赋差距的，别人学了就会用，甚至还会迁移创造，而大部分人是学了就忘的，并不知道自己学的这点东西对世界，对自己到底帮助在哪。要想破这个局，就要不断提升自己的认知水平，去俯视自己的内心。

2.在一个领域精通之后，其实可以把其中专业的任何事情都拿来和生活相对比，一定能找到生活中的现象和用途。所以其他自然学科也许也是相同的道理，所以一通百通就是这么来的。

3.一个人的毅力，坚持很重要，混乱是熵增，稳定是熵减，成功是从熵减到熵增再到熵减，而失败者永远都是脑子里熵减，行动上一直熵增

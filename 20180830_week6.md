## ARTS
algorithm, review, tips, share

### Algorithm
#### 1.报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n ，输出报数序列的第 n 项。

注意：整数顺序将表示为一个字符串。

示例 1:

输入: 1
输出: "1"
示例 2:

输入: 4
输出: "1211"
首先解释题目。我觉得问题就在于没有把题目解释清楚上。

1 读 one one

11 不读 one one one one,读 two one, 连着一起相同的数会先说数量再说值。

以上是基础。接下来看怎么得到下一项的结果。从题目所给出的示例4 ： 1211 到 5 : 111221。1211 第一位是1，所以读作 one one，也就是 1 1 .2读作one two, 
所以是12. 11连着读作two one, 所以是21.这所有加起来就是答案 111221。

思路：根据报数的特点，我们可以根据上一项的结果推导下一项。我们遍历上一项，辅以计数变量统计一下某些数字出现的次数。同时我们要不断保存上一项。
```
class Solution:  
    def countAndSay(self, n):  
        """ 
        :type n: int 
        :rtype: str 
        """  
        if n==1:#类似于斐波拉契数，后面的数跟前面的数有关  
            return '1'  
        if n==2:  
            return '11'
        #进行i=3时的循环时，它的上一项为'11'
        pre='11'
        
        #用for循环不断去计算逼近最后一次
        for i in range(3,n+1):  
            res=''#结果，每次报数都要初始化  
            cnt=1#计数变量
            
            length=len(pre)#遍历我们的上一项，所以记录它的长度
            for j in range(1,length):  
                if pre[j-1]==pre[j]:#相等则加一  
                    cnt+=1  
                else:
                    #一旦遇到不同的变量，就更新结果
                    res+=str(cnt)+pre[j-1]  
                    cnt=1#重置为1
            #把最后一项及它的数量加上
            res+=str(cnt)+pre[j]  
            pre=res#保存上一次的结果  
        return res
```
#### 2.实现strStr()
实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

思路：haystack中的字符串和needle的要重合
```
class Solution:
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        len1 = len(needle)
        if len1 == 0:
            return 0
        for i in range(len(haystack)):
            if haystack[i:i+len1] == needle:
                return i
        return -1
```

### Review
![我应该阅读论文吗？](http://michaelrbernste.in/2014/10/21/should-i-read-papers.html)

Should I read papers?

Should
就像你为什么要吃新鲜的食物，呼吸新鲜的空气一样，你有时候需要为你的工作目标做一些改善，看论文，一手的资料还是很棒的.所以你应该看论文

I
作为不管是传统IT还是新兴AI的工程师，能够和优秀的人在一起，每天过得很充实，这才有“我”的概念

Read
看论文和一般的博客和小说是不一样的，你需要按照一定的步骤去阅读，并且思考。好的论文要多读几遍。

Papers
要想清楚读的论文作者的目的是什么，解决了什么样的问题。看清问题的本质总是很重要。

### Tips
#### 模拟退火算法解决旅行商问题

模拟退火算法是一种近现代启发式算法，是根据高温固体降温过程中温度以及内能之间的关系来得到一个全局最优的解。

模拟退火使用基于概率的双方向随机搜索技术：当基于领域的一次操作使当前解的质量提高时，算法接收这个被改进的解作为新的当前解；
在相反的情况下，算法以概率p= e^((-∆C/T))接收当前解来说质量更差的解作为新的当前解。∆C相当于AI里面常说的误差函数，T为退火过程的控制参数。

算法步骤

step1 
由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。

step2 
计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。

step3 
判断新解是否被接受,判断的依据是一个接受准则，最常用的接受准则是 Metropolis 准则: 若Δt′<0则接受S′作为新的当前解S，否则以概率exp(-Δt′/T)接受S′作为新的当前解S。

step4 
当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。

** 解决旅行商问题：**

旅行商问题，即TSP问题（Travelling Salesman Problem）又译为旅行推销员问题、货郎担问题，是数学领域中著名问题之一。假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。

求解思想
 
关于解的形式，肯定是一组点的序列，表示了访问顺序。第一个点和最后一个点相同，均为起点。 
假设所有的点分别为 {v1,v2,…,vn},起点为 v1。
 
(1)解空间 
解空间 S 可表为的所有固定起点和终点的循环排列集合，即 
S={(π1,π2…,πn,π1)|π1=v1,(π2,…,πn)为{v2,v3,…,vn}的一个排列}。 
S 中的每一个排列表示一个回路，也就是一个解。 πi=j 表示在第 i-1 次访问目标 j。

(2)目标函数 
此时的目标函数为访问所有目标的路径长度或称代价函数。我们要求 
minf(π1,π2…,πn,π1)=∑1nd 

(3)新解的产生 
任选序号 u,v（u < v）交换u与v之间的顺序产生新的路径

我们就是希望通过这些步骤把旅行商问题求出最优解。城市两两之间的距离随着城市的变化而变化，所以经过互换，从而得到精髓函数p= e^(-(Ej-Ei)/KT)中的Ej的不同，从而可以进行Metropolis准则的判断，以一定的概率接受不好的解，可以跳出局部最优，得到全局最优。

得到的新解替代当前解，这样完成了一次迭代。只要设定好问题的底线，设置迭代的次数，最后便可以得到最优解。

### Share
分享马斯洛需求金字塔

底层有四层低层次的需求：生理需求，安全需求，归属与爱的需求，自尊需求。这些需求都是匮乏性的，是人类的基本需求。

但是还有高层的需求：认知需求，审美需求，还有自我实现需求。

而对于还在读研的自己来说，切切实实地感受到了底层四大需求的粘人，总感觉自己少了这几项就无法继续努力。

而拥有着高层次需求的人，他们有真正的自主人格，有着14中人格特征：

1.准确和充分地认识现实

2.宽容但又嫉恶如仇

3.对自己的体验全然敞开

4.以问题为中心，不以自我为中心

5.超然独立的性格

6.不迷信权威和文化

7.清新隽永的鉴赏力。

8.真切的社会情感

9.深厚的人际关系

10.民主风范

11.高度的道德感

12.批判精神

13.接收模糊状态

14.高创造力

怎么才能拥有这种自主般的人格呢？

1.重建你的内部评价体系

2.倾听并接受你内心的声音

3.把每一个别人都当做独一无二的人

4.无我地体验生活

5.全身心地献身事业

6.选择成长

7.真诚一致

8.从小处做起

9.勤奋
